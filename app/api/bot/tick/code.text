// app/api/bot/tick/route.ts
export const runtime = "nodejs";
export const dynamic = "force-dynamic";
export const revalidate = 0;

import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { getQuote } from "@/lib/quote";
import {
  isWeekdayET,
  isMarketHoursET,
  yyyyMmDdET,
  nowET,
} from "@/lib/market";

/** ========================
 *   THROTTLE / COALESCE
 *  =======================*/
let lastTickAt = 0;
let lastTickResponse: any = null;
let pendingTick: Promise<any> | null = null;
const MIN_TICK_MS = 500;

/** ========================
 *   CONFIG
 *  =======================*/
const START_CASH = 4000;

// ✅ New: fixed-budget sizing per trade
const INVEST_BUDGET = 4000;     // use up to $4,000 per entry; if cash < 4k, use all available

// Risk: single-entry / single-exit
const TARGET_PCT = 0.10;        // +10% take-profit
const STOP_PCT   = -0.05;       // -5% stop-loss
const MAX_SLIPPAGE_PCT = 0.003; // +0.3% pegged-limit above ref/mid

// Snapshot/selection
const SNAPSHOT_STALE_MS = 5_000;
const TOP_CANDIDATES    = 8;    // AI may only pick from first 8

// Entry window
function entryWindowOpenET() {
  const d = nowET();
  const mins = d.getHours() * 60 + d.getMinutes();
  return mins >= (9 * 60 + 34) && mins <= (10 * 60 + 15);
}
// Force-buy at 10:15 (if still flat)
function isForceBuyMinuteET() {
  const d = nowET();
  return d.getHours() === 10 && d.getMinutes() === 15;
}

// ===== Mandatory exit cutoff (>= 15:55 ET) =====
function isMandatoryExitET() {
  const d = nowET();
  const mins = d.getHours() * 60 + d.getMinutes();
  return mins >= (15 * 60 + 55); // 15:55 or later, same trading day
}

/** ========================
 *   Types & helpers
 *  =======================*/
type Candle = { date: string; open: number; high: number; low: number; close: number; volume: number };
type SnapStock = {
  ticker: string;
  price?: number | null;
  changesPercentage?: number | null;
  volume?: number | null;
  avgVolume?: number | null;
  marketCap?: number | null;
};

const fmtUSD = (n: number) => `$${n.toFixed(2)}`;
const fmtPct = (p: number) => `${(p * 100).toFixed(2)}%`;

function log(msg: string, extra?: any) {
  if (extra !== undefined) {
    try { console.log(`[bot:0934-1015] ${msg}`, typeof extra === "string" ? extra : JSON.stringify(extra)); }
    catch { console.log(`[bot:0934-1015] ${msg}`); }
  } else {
    console.log(`[bot:0934-1015] ${msg}`);
  }
}

function toET(dateIso: string): Date {
  return new Date(new Date(dateIso).toLocaleString("en-US", { timeZone: "America/New_York" }));
}
function isSameETDay(d: Date, ymd: string) {
  const mo = String(d.getMonth() + 1).padStart(2, "0");
  const da = String(d.getDate()).padStart(2, "0");
  return `${d.getFullYear()}-${mo}-${da}` === ymd;
}

/** ===== 1m candles via your proxy ===== */
async function fetchCandles1m(symbol: string, limit = 240): Promise<Candle[]> {
  const rel = `/api/fmp/candles?symbol=${encodeURIComponent(symbol)}&interval=1min&limit=${limit}`;
  const res = await fetch(rel, { cache: "no-store" });
  if (!res.ok) return [];
  const j = await res.json();
  const arr = Array.isArray(j?.candles) ? j.candles : [];
  return arr.map((c: any) => ({
    date: c.date,
    open: Number(c.open),
    high: Number(c.high),
    low: Number(c.low),
    close: Number(c.close),
    volume: Number(c.volume),
  }));
}

/** ===== Opening range (9:30–9:34) ===== */
function computeOpeningRange(candles: Candle[], todayYMD: string) {
  const window = candles.filter((c) => {
    const d = toET(c.date);
    return isSameETDay(d, todayYMD) && d.getHours() === 9 && d.getMinutes() >= 30 && d.getMinutes() <= 34;
  });
  if (!window.length) return null;
  const high = Math.max(...window.map((c) => c.high));
  const low  = Math.min(...window.map((c) => c.low));
  return { high, low, count: window.length };
}

/** ===== Session VWAP (from ~9:30) ===== */
function computeSessionVWAP(candles: Candle[], todayYMD: string) {
  const session = candles.filter((c) => {
    const d = toET(c.date);
    const mins = d.getHours() * 60 + d.getMinutes();
    return isSameETDay(d, todayYMD) && mins >= 9 * 60 + 30; // >= 09:30 ET
  });
  if (!session.length) return null;
  let pvSum = 0, volSum = 0;
  for (const c of session) {
    const typical = (c.high + c.low + c.close) / 3;
    pvSum += typical * c.volume;
    volSum += c.volume;
  }
  return volSum > 0 ? pvSum / volSum : null;
}

/** ===== Volume pulse: latest 1m vs avg of prior N ===== */
function computeVolumePulse(candles: Candle[], todayYMD: string, lookback = 5) {
  const dayC = candles.filter((c) => isSameETDay(toET(c.date), todayYMD));
  if (dayC.length < lookback + 1) return null;
  const latest = dayC[dayC.length - 1];
  const prior = dayC.slice(-1 - lookback, -1);
  const avgPrior = prior.reduce((s, c) => s + c.volume, 0) / lookback;
  if (!avgPrior) return { mult: null, latestVol: latest.volume, avgPrior };
  return { mult: latest.volume / avgPrior, latestVol: latest.volume, avgPrior };
}

/** Day high so far (before latest bar) */
function computeDayHighSoFar(candles: Candle[], todayYMD: string) {
  const day = candles.filter((c) => isSameETDay(toET(c.date), todayYMD));
  if (day.length < 2) return null;
  const prior = day.slice(0, -1);
  return Math.max(...prior.map((c) => c.high));
}

/** Micro-base breakout (break of last N highs) */
function brokeRecentHighs(candles: Candle[], todayYMD: string, n = 3) {
  const day = candles.filter((c) => isSameETDay(toET(c.date), todayYMD));
  if (day.length < n + 1) return false;
  const last = day[day.length - 1];
  const prior = day.slice(-1 - n, -1);
  const priorMax = Math.max(...prior.map((c) => c.high));
  return last.close > priorMax;
}

/** ===== Base URL & snapshot ===== */
function getBaseUrl(req: Request) {
  const envBase = process.env.NEXT_PUBLIC_BASE_URL?.trim();
  if (envBase) return envBase.replace(/\/+$/, "");
  const proto = (req.headers.get("x-forwarded-proto") || "http").split(",")[0].trim();
  const host  = (req.headers.get("x-forwarded-host") || req.headers.get("host") || "").split(",")[0].trim();
  return `${proto}://${host}`;
}

async function getSnapshot(baseUrl: string): Promise<{ stocks: SnapStock[]; updatedAt: string } | null> {
  try {
    const r = await fetch(`${baseUrl}/api/stocks/snapshot`, { cache: "no-store" });
    if (!r.ok) return null;
    const j = await r.json();
    return { stocks: Array.isArray(j?.stocks) ? j.stocks : [], updatedAt: j?.updatedAt || new Date().toISOString() };
  } catch { return null; }
}

/** Ensure a same-day AI pick using ONLY the snapshot’s top-8 */
async function ensureTodayRecommendationFromSnapshot(req: Request, topStocks: SnapStock[]) {
  const today = yyyyMmDdET();
  let lastRec = await prisma.recommendation.findFirst({ orderBy: { id: "desc" } });

  const recDay =
    lastRec?.at instanceof Date
      ? `${lastRec.at.getFullYear()}-${String(lastRec.at.getMonth() + 1).padStart(2, "0")}-${String(
          lastRec.at.getDate()
        ).padStart(2, "0")}`
      : null;
  if (lastRec && recDay === today) return lastRec;

  if (!entryWindowOpenET() || !topStocks.length) return lastRec || null;

  try {
    const base = getBaseUrl(req);
       const rRes = await fetch(`${base}/api/recommendation`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ stocks: topStocks }),
      cache: "no-store",
    });
    if (!rRes.ok) return lastRec || null;
    const rJson = await rRes.json();

    const txt: string = rJson?.recommendation || "";
    const m = /Pick:\s*([A-Z][A-Z0-9.\-]*)/i.exec(txt);
    const ticker = m?.[1]?.toUpperCase() || null;
    if (!ticker) return lastRec || null;

    const priceCandidate =
      topStocks.find((s) => s.ticker === ticker)?.price ?? (await getQuote(ticker));
    if (priceCandidate == null || !Number.isFinite(Number(priceCandidate))) {
      return lastRec || null;
    }
    const priceNum = Number(priceCandidate);

    lastRec = await prisma.recommendation.create({ data: { ticker, price: priceNum } });
    log("new daily AI pick", { ticker, price: priceNum });
    return lastRec;
  } catch {
    return lastRec || null;
  }
}

/** ========================
 *   Route handlers (throttled)
 *  =======================*/
export async function GET(req: Request) { return handle(req); }
export async function POST(req: Request) { return handle(req); }

async function handle(req: Request) {
  const now = Date.now();

  if (pendingTick) {
    const data = await pendingTick;
    return NextResponse.json(data);
  }
  if (lastTickResponse && now - lastTickAt < MIN_TICK_MS) {
    return NextResponse.json(lastTickResponse);
  }

  pendingTick = (async () => {
    const debug: any = { reasons: [] as string[] };
    const setStatus = (msg: string) => { console.log(msg); debug.lastMessage = msg; };

    // Ensure state & read DB
    let state = await (async () => {
      let s = await prisma.botState.findUnique({ where: { id: 1 } });
      if (!s) {
        s = await prisma.botState.create({
          data: { id: 1, cash: START_CASH, pnl: 0, equity: START_CASH },
        });
      }
      return s;
    })();

    let openPos = await prisma.position.findFirst({ where: { open: true }, orderBy: { id: "desc" } });
    let lastRec = await prisma.recommendation.findFirst({ orderBy: { id: "desc" } });
    let livePrice: number | null = null;
    const today = yyyyMmDdET();

    // ===== Mandatory exit (>= 15:55 ET) — runs BEFORE any early returns =====
    if (openPos && isMandatoryExitET()) {
      try {
        const base = getBaseUrl(req);
        const snapshot = await getSnapshot(base);
        const s = snapshot?.stocks?.find(x => x.ticker === openPos!.ticker);
        const p = (s?.price != null && Number.isFinite(Number(s.price)))
          ? Number(s.price)
          : Number(await getQuote(openPos!.ticker));

        if (p != null && Number.isFinite(p)) {
          const exitVal = openPos.shares * p;
          const entry = Number(openPos.entryPrice);
          const entryVal = openPos.shares * entry;
          const realized = exitVal - entryVal;

          await prisma.trade.create({
            data: { side: "SELL", ticker: openPos.ticker, price: p, shares: openPos.shares },
          });
          await prisma.position.update({
            where: { id: openPos.id },
            data: { open: false, exitPrice: p, exitAt: nowET() },
          });
          state = await prisma.botState.update({
            where: { id: 1 },
            data: {
              cash: Number(state.cash) + exitVal,
              pnl: Number(state.pnl) + realized,
              equity: Number(state.cash) + exitVal,
            },
          });

          const exitMsg =
            `⏱️ Mandatory 15:55+ exit ${openPos.ticker} x${openPos.shares} @ ${fmtUSD(p)} | ` +
            `P/L ${realized >= 0 ? "+" : ""}${fmtUSD(realized)} (${fmtPct((p - entry) / entry)})`;
          console.log(exitMsg);
          debug.lastMessage = exitMsg;
          openPos = null;
        } else {
          debug.reasons.push("mandatory_exit_no_price");
          setStatus("⚠️ Mandatory exit: no price available.");
        }
      } catch (e: any) {
        debug.reasons.push("mandatory_exit_exception");
        log("mandatory exit error", e?.message || e);
      }
    }

    if (!isWeekdayET()) {
      debug.reasons.push("not_weekday");
      setStatus("⛔ Not a weekday — trading disabled.");
      return {
        state, lastRec, position: openPos, live: null,
        serverTimeET: nowET().toISOString(),
        skipped: "not_weekday", debug
      };
    }

    const marketOpen = isMarketHoursET();

    // Pull snapshot
    let snapshot: { stocks: SnapStock[]; updatedAt: string } | null = null;
    const base = getBaseUrl(req);
    try {
      snapshot = await getSnapshot(base);
    } catch {}

    if (!openPos && (!snapshot?.stocks?.length || (Date.now() - new Date(snapshot?.updatedAt || 0).getTime()) > SNAPSHOT_STALE_MS)) {
      debug.reasons.push("no_or_stale_snapshot");
      setStatus("⚠️ No fresh snapshot yet — waiting for data.");
      return {
        state, lastRec, position: openPos, live: null,
        serverTimeET: nowET().toISOString(),
        skipped: "no_or_stale_snapshot", debug
      };
    }

    const top8: SnapStock[] = (snapshot?.stocks || []).slice(0, TOP_CANDIDATES);
    debug.top8 = top8.map(s => s.ticker);

    // Live price for UI (pos or pick)
    const symbol = openPos?.ticker ?? lastRec?.ticker ?? null;
    if (symbol) {
      const s = snapshot?.stocks?.find((x) => x.ticker === symbol);
      if (s?.price != null && Number.isFinite(Number(s.price))) {
        livePrice = Number(s.price);
      } else {
        const q = await getQuote(symbol);
        if (q != null && Number.isFinite(Number(q))) livePrice = Number(q);
      }
    }

    const inEntryWindow = entryWindowOpenET();
    debug.inEntryWindow_0934_1015 = inEntryWindow;
    debug.isForceBuyMinute_1015 = isForceBuyMinuteET();
    debug.isMandatoryExit_1555 = isMandatoryExitET();

    // Ensure a same-day AI pick if needed (only from top-8)
    if (!openPos && inEntryWindow && (!lastRec || !isSameETDay(lastRec.at ?? new Date(), today))) {
      lastRec = await ensureTodayRecommendationFromSnapshot(req, top8);
      if (lastRec) log("using AI pick", { ticker: lastRec.ticker, price: lastRec.price });
    }

    /** ========================
     *   ENTRY LOGIC (1 trade/day) with $4k cap
     *  =======================*/
    if (!openPos && inEntryWindow && marketOpen && (state.lastRunDay !== today) && lastRec?.ticker) {
      try {
        const candles = await fetchCandles1m(lastRec.ticker, 240);
        const dayCandles = candles.filter((c) => isSameETDay(toET(c.date), today));
        if (dayCandles.length) {
          const orRange = computeOpeningRange(candles, today);
          const vwap = computeSessionVWAP(candles, today);
          const volPulse = computeVolumePulse(candles, today, 5);
          const last = dayCandles[dayCandles.length - 1];
          const dayHighSoFar = computeDayHighSoFar(candles, today);

          const aboveVWAP = vwap != null && last ? last.close >= vwap : false;
          const brokeORHigh = !!(orRange && last && last.close > orRange.high);
          const pullbackOK = !!(orRange && last && last.low >= orRange.high * 0.985);
          const brokeDayHigh = (typeof dayHighSoFar === "number" && last) ? last.close > dayHighSoFar : brokeORHigh;
          const brokeMicro = brokeRecentHighs(candles, today, 3);
          const volOK = (volPulse?.mult ?? 0) >= 1.1;

          const armed =
            aboveVWAP &&
            volOK &&
            ( (brokeORHigh && pullbackOK) || brokeDayHigh || brokeMicro );

          if (armed || isForceBuyMinuteET()) {
            // atomically claim today's slot
            const claim = await prisma.botState.updateMany({
              where: { id: 1, OR: [{ lastRunDay: null }, { lastRunDay: { not: today } }] },
              data: { lastRunDay: today },
            });
            const claimed = claim.count === 1;
            debug.claimAttempted = true;
            debug.claimWon = claimed;

            if (claimed) {
              // re-check position after claim
              openPos = await prisma.position.findFirst({ where: { open: true }, orderBy: { id: "desc" } });
              if (!openPos) {
                // price selection: snapshot -> rec.price -> live quote
                let entryRefPrice: number | null = null;
                const snapMatch = snapshot?.stocks?.find(s => s.ticker === lastRec!.ticker)?.price;
                if (snapMatch != null && Number.isFinite(Number(snapMatch))) entryRefPrice = Number(snapMatch);
                if (entryRefPrice == null && Number.isFinite(Number(lastRec!.price))) entryRefPrice = Number(lastRec!.price);
                if (entryRefPrice == null) {
                  const q = await getQuote(lastRec!.ticker);
                  if (q != null && Number.isFinite(Number(q))) entryRefPrice = Number(q);
                }

                if (entryRefPrice != null) {
                  const mid   = entryRefPrice;
                  const limit = mid * (1 + MAX_SLIPPAGE_PCT);

                  const cashNum = Number(state.cash);
                  const budget  = Math.min(cashNum, INVEST_BUDGET);  // ✅ cap at $4k, or all if < $4k
                  const shares  = Math.floor(budget / limit);

                  if (shares > 0) {
                    const used = shares * limit;

                    const pos = await prisma.position.create({
                      data: { ticker: lastRec!.ticker, entryPrice: limit, shares, open: true },
                    });
                    openPos = pos;

                    await prisma.trade.create({
                      data: { side: "BUY", ticker: lastRec!.ticker, price: limit, shares },
                    });

                    state = await prisma.botState.update({
                      where: { id: 1 },
                      data: {
                        cash: cashNum - used,
                        equity: cashNum - used + shares * (livePrice ?? limit),
                      },
                    });

                    const tp = limit * (1 + TARGET_PCT);
                    const sl = limit * (1 + STOP_PCT);
                    const reasonTag = armed ? "Signal Entry" : "10:15 Force Buy";
                    const entryMsg =
                      `🚀 BUY ${lastRec!.ticker} (${reasonTag}) @ ${fmtUSD(limit)} ` +
                      `| size: ~${fmtUSD(used)} | TP ${fmtUSD(tp)} / SL ${fmtUSD(sl)}`;
                    console.log(entryMsg);
                    debug.lastMessage = entryMsg;
                  } else {
                    debug.reasons.push("insufficient_budget_for_one_share");
                    setStatus("⚠️ No entry: budget too small for one share at limit.");
                  }
                } else {
                  debug.reasons.push("no_price_for_entry");
                  setStatus(`⚠️ No price available for ${lastRec!.ticker} — skipping.`);
                }
              } else {
                debug.reasons.push("position_open_after_claim");
              }
            } else {
              debug.reasons.push("day_lock_already_claimed");
            }
          } else {
            setStatus(`🟡 Watching ${lastRec.ticker} — needs VWAP + vol + break (OR/day/micro)`);
          }
        } else {
          debug.reasons.push("no_day_candles");
          setStatus("⚠️ No intraday candles yet.");
        }
      } catch (e: any) {
        log("entry evaluation error", e?.message || e);
        setStatus("❗ Entry error — see server logs.");
      }
    }

    /** ========================
     *   POSITION MANAGEMENT
     *  =======================*/
    if (openPos) {
      try {
        // latest price
        let p: number | null = null;
        const s = snapshot?.stocks?.find(x => x.ticker === openPos!.ticker);
        if (s?.price != null && Number.isFinite(Number(s.price))) {
          p = Number(s.price);
        } else {
          const q = await getQuote(openPos.ticker);
          if (q != null && Number.isFinite(Number(q))) p = Number(q);
        }

        if (p != null) {
          const entry = Number(openPos.entryPrice);
          const change = (p - entry) / entry;
          const hitSL = change <= STOP_PCT;
          const hitTP = change >= TARGET_PCT;

          // Keep equity fresh
          const equityNow = Number(state.cash) + openPos.shares * p;
          if (Number(state.equity) !== equityNow) {
            state = await prisma.botState.update({ where: { id: 1 }, data: { equity: equityNow } });
          }

          const pct = (p - entry) / entry;
          setStatus(`📈 Holding ${openPos.ticker} x${openPos.shares} — ${fmtUSD(p)} (P/L ${pct >= 0 ? "+" : ""}${fmtPct(pct)})`);

          if (hitSL || hitTP) {
            const exitVal = openPos.shares * p;
            const entryVal = openPos.shares * entry;
            const realized = exitVal - entryVal;

            await prisma.trade.create({
              data: { side: "SELL", ticker: openPos.ticker, price: p, shares: openPos.shares },
            });
            await prisma.position.update({
              where: { id: openPos.id },
              data: { open: false, exitPrice: p, exitAt: nowET() },
            });
            state = await prisma.botState.update({
              where: { id: 1 },
              data: {
                cash: Number(state.cash) + exitVal,
                pnl: Number(state.pnl) + realized,
                equity: Number(state.cash) + exitVal,
              },
            });

            const reason = hitTP ? "Take Profit" : "Stop Loss";
            const exitMsg = `🏁 Exit ${openPos.ticker} x${openPos.shares} @ ${fmtUSD(p)} | ${reason} | P/L ${realized >= 0 ? "+" : ""}${fmtUSD(realized)} (${fmtPct((p - entry) / entry)})`;
            console.log(exitMsg);
            debug.lastMessage = exitMsg;

            openPos = null;
          }
        }
      } catch (e: any) {
        log("manage error", e?.message || e);
      }
    }

    /** ===== Diagnostics back to UI ===== */
    let signals: any = null;
    try {
      const candidate = openPos?.ticker ?? lastRec?.ticker ?? null;
      if (candidate && entryWindowOpenET()) {
        const candles = await fetchCandles1m(candidate, 240);
        const orRange = computeOpeningRange(candles, today);
        const vwap = computeSessionVWAP(candles, today);
        const dayCandles = candles.filter((c) => isSameETDay(toET(c.date), today));
        const last = dayCandles[dayCandles.length - 1];
        const volPulse = computeVolumePulse(candles, today, 5);
        const dayHighSoFar = computeDayHighSoFar(candles, today);

        const aboveVWAP = vwap != null && last ? last.close >= vwap : false;
        const brokeORHigh = orRange && last ? last.close > orRange.high : false;
        const pullbackOK = orRange && last ? last.low >= orRange.high * 0.985 : false;
        const brokeDayHigh = (typeof dayHighSoFar === "number" && last)
          ? last.close > dayHighSoFar
          : (brokeORHigh || false);
        const brokeRecent = brokeRecentHighs(candles, today, 3);
        const volMult = volPulse?.mult ?? null;

        const armed =
          aboveVWAP &&
          (volMult ?? 0) >= 1.1 &&
          ( (brokeORHigh && pullbackOK) || brokeDayHigh || brokeRecent );

        signals = {
          ticker: candidate,
          timeET: nowET().toISOString(),
          orHigh: orRange?.high ?? null,
          orLow: orRange?.low ?? null,
          vwap: vwap ?? null,
          lastClose: last?.close ?? null,
          volPulse: volMult,
          dayHighSoFar: dayHighSoFar ?? null,
          brokeRecent3Highs: brokeRecent,
          armed,
        };
      }
    } catch {}

    return {
      state,
      lastRec,
      position: openPos,
      live: { ticker: openPos?.ticker ?? lastRec?.ticker ?? null, price: livePrice },
      serverTimeET: nowET().toISOString(),
      info: {
        entryWindowOpen_0934_1015: entryWindowOpenET(),
        isForceBuyMinute_1015: isForceBuyMinuteET(),
        isMandatoryExit_1555: isMandatoryExitET(),
        snapshotAgeMs: snapshot ? (Date.now() - new Date(snapshot.updatedAt).getTime()) : null,
        investBudget: INVEST_BUDGET,
      },
      signals,
      debug,
    };
  })();

  try {
    const data = await pendingTick;
    lastTickAt = Date.now();
    lastTickResponse = data;
    return NextResponse.json(data);
  } finally {
    pendingTick = null;
  }
}
